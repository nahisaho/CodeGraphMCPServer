# アーキテクチャ決定記録（ADR）

## 概要

このドキュメントは、CodeGraph MCP Server の設計における重要なアーキテクチャ決定を記録します。
各ADRは、決定の背景、検討した選択肢、決定内容、およびその影響を明確にします。

**関連要件**: すべての要件に横断的に影響

---

## ADR-001: Library-First アーキテクチャパターンの採用

### ステータス
**承認済み** (2024-01)

### コンテキスト
CodeGraph MCP Server は、複数のMCPクライアント（Claude Desktop、GitHub Copilot、Cursor等）から利用される。
アーキテクチャパターンとして、以下の選択肢が存在する：

1. **Monolithic Server**: 全機能を単一プロセスで提供
2. **Microservices**: 機能ごとに分散サービス化
3. **Library-First**: コア機能をライブラリとして設計し、薄いMCP層で公開

### 決定
**Library-First パターン**を採用する。

```
┌─────────────────────────────────────────┐
│           MCP Server Layer              │  ← 薄いラッパー
│  (Tools, Resources, Prompts定義)        │
├─────────────────────────────────────────┤
│           Core Library Layer            │  ← ビジネスロジック
│  (ASTParser, GraphEngine, Indexer...)   │
├─────────────────────────────────────────┤
│           Storage Layer                 │  ← データ永続化
│  (SQLite, Cache, Vector)                │
└─────────────────────────────────────────┘
```

### 根拠
1. **テスト容易性**: ライブラリ層は MCP プロトコルに依存せずユニットテスト可能
2. **再利用性**: CLI ツール、Web API 等への展開が容易
3. **関心の分離**: プロトコル処理とビジネスロジックを明確に分離
4. **段階的開発**: コア機能を先に安定させ、インターフェースを後から追加

### 影響
- **ポジティブ**: 
  - テストカバレッジ向上（目標80%以上）
  - 将来の拡張が容易
  - コードの可読性向上
- **ネガティブ**: 
  - レイヤー間の依存関係管理が必要
  - 初期設計に時間を要する

### 関連要件
- REQ-NFR-001（テスト容易性）
- REQ-NFR-002（拡張性）

---

## ADR-002: SQLite の採用（Neo4j/RedisGraph 不採用）

### ステータス
**承認済み** (2024-01)

### コンテキスト
コードグラフのデータ永続化に使用するデータベースを選定する必要がある。
検討した選択肢：

| 選択肢 | 特徴 |
|--------|------|
| **Neo4j** | 本格的なグラフDB、Cypher クエリ、高機能 |
| **RedisGraph** | インメモリグラフDB、高速、Cypher 対応 |
| **SQLite** | リレーショナルDB、ゼロ設定、埋め込み型 |
| **DuckDB** | 分析特化、列指向、埋め込み型 |

### 決定
**SQLite** を主要ストレージとして採用する。

### 根拠
1. **ゼロ設定**: 外部プロセス不要、ファイルベースで即座に利用可能
2. **移植性**: 単一ファイルでプロジェクト間移動が容易
3. **十分な性能**: 10万エンティティ規模では十分な性能
4. **成熟度**: 安定性が高く、信頼性実績が豊富
5. **MCPの思想**: ローカルファースト、軽量インストール

```python
# グラフ操作はアプリケーション層で実装
class GraphEngine:
    def __init__(self, db_path: Path):
        self._graph = nx.DiGraph()  # NetworkX でグラフ操作
        self._storage = SQLiteStorage(db_path)  # SQLite で永続化
```

### 影響
- **ポジティブ**: 
  - インストールが簡単（pip install のみ）
  - CI/CD でのテストが容易
  - オフライン環境でも動作
- **ネガティブ**: 
  - 複雑なグラフクエリはアプリケーション層で実装必要
  - 超大規模リポジトリでは性能限界あり（10万エンティティ以上）

### 検討した代替案の却下理由
- **Neo4j**: 外部サーバー必須、セットアップ複雑、ライセンス制約
- **RedisGraph**: Redis サーバー必須、インメモリで永続化に課題
- **DuckDB**: グラフ操作に最適化されていない

### 関連要件
- REQ-STR-001（永続化）
- REQ-NFR-003（インストール容易性）

---

## ADR-003: Tree-sitter によるAST解析

### ステータス
**承認済み** (2024-01)

### コンテキスト
複数言語のソースコードを解析し、抽象構文木（AST）を取得する方法を選定する必要がある。

検討した選択肢：

| 選択肢 | 特徴 |
|--------|------|
| **Tree-sitter** | 汎用パーサー、インクリメンタル、多言語対応 |
| **言語別パーサー** | ast(Python)、typescript-parser等、高精度 |
| **正規表現ベース** | 軽量、単純、精度低 |
| **LSP統合** | 言語サーバー利用、高精度、重い |

### 決定
**Tree-sitter** を採用する。

### 根拠
1. **多言語対応**: Python、TypeScript、JavaScript、Rust等を統一APIで解析
2. **インクリメンタル解析**: 部分変更時の再解析が高速
3. **耐障害性**: 構文エラーがあっても部分的にパース可能
4. **コミュニティ**: GitHub が開発、広く採用されている

```python
# 統一されたAPI で複数言語を解析
LANGUAGE_CONFIG = {
    "python": {
        "parser": "tree_sitter_python",
        "extensions": [".py"],
        "queries": {...}
    },
    "typescript": {
        "parser": "tree_sitter_typescript",
        "extensions": [".ts", ".tsx"],
        "queries": {...}
    }
}
```

### 影響
- **ポジティブ**: 
  - 新言語追加が設定のみで可能
  - 構文エラーに対する耐性
  - 高速なインクリメンタル更新
- **ネガティブ**: 
  - 型情報取得に限界（静的解析のみ）
  - クエリパターンは言語ごとに定義が必要

### 関連要件
- REQ-AST-001~005（AST解析関連）
- REQ-NFR-004（多言語対応）

---

## ADR-004: MCP SDK (Python) の採用

### ステータス
**承認済み** (2024-01)

### コンテキスト
MCP プロトコルを実装する方法を選定する。

検討した選択肢：

| 選択肢 | 特徴 |
|--------|------|
| **MCP SDK (Python)** | Anthropic 公式、型安全、ドキュメント充実 |
| **MCP SDK (TypeScript)** | Anthropic 公式、Node.js 環境 |
| **自前実装** | JSON-RPC 2.0 直接実装、柔軟性高 |

### 決定
**MCP SDK (Python)** を採用する。

### 根拠
1. **公式サポート**: Anthropic が提供、仕様変更への追従が容易
2. **Pythonエコシステム**: Tree-sitter、NetworkX等との親和性
3. **型安全性**: Pydantic ベースで型チェック、バリデーション自動化
4. **非同期対応**: asyncio ネイティブ、高い並行性

```python
from mcp.server import Server
from mcp.types import Tool, Resource, Prompt

server = Server("codegraph")

@server.tool()
async def query_codebase(query: str) -> list[dict]:
    """型安全なツール定義"""
    return await core.query(query)
```

### 影響
- **ポジティブ**: 
  - 開発速度の向上
  - プロトコル準拠の保証
  - エラーハンドリングの簡素化
- **ネガティブ**: 
  - SDK のバージョンアップへの追従が必要
  - SDK の制約内での実装

### 関連要件
- REQ-TLS-001~014（ツール定義）
- REQ-RSC-001~004（リソース定義）
- REQ-PRM-001~006（プロンプト定義）

---

## ADR-005: NetworkX によるグラフ操作

### ステータス
**承認済み** (2024-01)

### コンテキスト
メモリ上でのグラフ操作ライブラリを選定する。

検討した選択肢：

| 選択肢 | 特徴 |
|--------|------|
| **NetworkX** | 汎用、アルゴリズム豊富、成熟 |
| **igraph** | 高速、C実装、大規模向け |
| **graph-tool** | 高性能、C++実装、インストール複雑 |
| **自前実装** | 軽量、最適化可能 |

### 決定
**NetworkX** を採用する。

### 根拠
1. **アルゴリズム豊富**: コミュニティ検出、最短経路、中心性計算等が組み込み
2. **学習コスト低**: ドキュメント充実、広く使われている
3. **Python ネイティブ**: 追加の依存関係が少ない
4. **十分な性能**: 対象規模（10万ノード）では十分

```python
import networkx as nx

# コミュニティ検出
communities = nx.community.louvain_communities(graph)

# 最短経路
path = nx.shortest_path(graph, source, target)

# 中心性計算
centrality = nx.pagerank(graph)
```

### 影響
- **ポジティブ**: 
  - 豊富なグラフアルゴリズムを即座に利用可能
  - デバッグ・可視化ツールとの統合が容易
- **ネガティブ**: 
  - 超大規模グラフでは性能限界（100万ノード以上）
  - メモリ使用量が多い

### 関連要件
- REQ-GRF-001~006（グラフ構築関連）
- REQ-SEM-001~004（セマンティック解析）

---

## ADR-006: Pydantic によるデータモデリング

### ステータス
**承認済み** (2024-01)

### コンテキスト
ドメインオブジェクトのデータモデリング方法を選定する。

検討した選択肢：

| 選択肢 | 特徴 |
|--------|------|
| **Pydantic** | 型バリデーション、シリアライズ、高機能 |
| **dataclasses** | 標準ライブラリ、軽量、シンプル |
| **attrs** | 高性能、柔軟性、スロット対応 |
| **TypedDict** | 型ヒントのみ、ランタイム検証なし |

### 決定
**Pydantic v2** を採用する。

### 根拠
1. **MCP SDK との統合**: MCP SDK が Pydantic を使用
2. **自動バリデーション**: 入力データの検証を宣言的に記述
3. **シリアライズ**: JSON との変換が自動化
4. **IDE サポート**: 型推論が効く

```python
from pydantic import BaseModel, Field

class Entity(BaseModel):
    """型安全なエンティティモデル"""
    id: str = Field(..., description="一意識別子")
    name: str = Field(..., description="エンティティ名")
    type: EntityType = Field(..., description="エンティティ種別")
    file_path: Path = Field(..., description="ファイルパス")
    
    model_config = {"frozen": True}  # イミュータブル
```

### 影響
- **ポジティブ**: 
  - データの整合性が保証される
  - API ドキュメント自動生成に活用可能
  - シリアライズ/デシリアライズの統一
- **ネガティブ**: 
  - dataclasses より若干オーバーヘッドあり
  - Pydantic v1 → v2 の移行に注意

### 関連要件
- REQ-AST-001（パース結果のモデル化）
- REQ-NFR-001（型安全性）

---

## ADR-007: 非同期I/O (asyncio) の全面採用

### ステータス
**承認済み** (2024-01)

### コンテキスト
I/O 処理の実装方式を選定する。

検討した選択肢：

| 選択肢 | 特徴 |
|--------|------|
| **asyncio** | Python標準、非同期I/O、高並行性 |
| **threading** | スレッドベース、GILの制約 |
| **multiprocessing** | プロセスベース、重い |
| **同期処理** | シンプル、ブロッキング |

### 決定
**asyncio による非同期 I/O** を全面採用する。

### 根拠
1. **MCP SDK 要件**: MCP SDK が asyncio ベース
2. **高い並行性**: 複数クライアントからの同時リクエスト対応
3. **I/O バウンド最適**: ファイル読み込み、DB アクセスが主要処理
4. **リソース効率**: スレッドより軽量

```python
import asyncio
import aiosqlite

async def index_repository(path: Path) -> None:
    """非同期でリポジトリをインデックス"""
    async with aiosqlite.connect(db_path) as db:
        for file in await asyncio.to_thread(list_files, path):
            ast = await asyncio.to_thread(parse_file, file)
            await store_entities(db, ast.entities)
```

### 影響
- **ポジティブ**: 
  - 高い並行処理性能
  - リソース効率が良い
  - MCP SDK との自然な統合
- **ネガティブ**: 
  - 非同期コードの複雑性
  - デバッグが難しい場合がある
  - 同期ライブラリとの統合に `to_thread` が必要

### 関連要件
- REQ-NFR-002（並行処理）
- REQ-IDX-003（インクリメンタルインデックス）

---

## ADR-008: LRU キャッシュ戦略

### ステータス
**承認済み** (2024-01)

### コンテキスト
パフォーマンス最適化のためのキャッシュ戦略を選定する。

検討した選択肢：

| 選択肢 | 特徴 |
|--------|------|
| **LRU** | 最も古いアクセスを削除、シンプル |
| **LFU** | 最も使用頻度が低いものを削除 |
| **TTL** | 時間ベースで期限切れ |
| **Write-through** | 書き込み時にキャッシュ更新 |

### 決定
**LRU (Least Recently Used)** をベースとしたキャッシュ戦略を採用する。

### 根拠
1. **アクセスパターン**: 最近編集したファイルが繰り返しアクセスされる
2. **実装シンプル**: Python 標準の `functools.lru_cache` 活用可能
3. **メモリ効率**: サイズ上限を設定可能
4. **予測可能性**: 動作が直感的で理解しやすい

```python
from functools import lru_cache
from cachetools import TTLCache

# AST キャッシュ（ファイル内容ベース）
@lru_cache(maxsize=500)
def get_cached_ast(file_hash: str) -> AST:
    ...

# クエリ結果キャッシュ（TTL付き）
query_cache = TTLCache(maxsize=100, ttl=300)
```

### 影響
- **ポジティブ**: 
  - 繰り返しクエリの高速化
  - AST 再パースの回避
  - メモリ使用量の制御
- **ネガティブ**: 
  - キャッシュ無効化ロジックが必要
  - メモリオーバーヘッド

### 関連要件
- REQ-STR-003（キャッシュ機構）
- REQ-NFR-005（応答時間）

---

## ADR-009: セマンティックバージョニングの採用

### ステータス
**承認済み** (2024-01)

### コンテキスト
プロジェクトのバージョン管理方式を選定する。

### 決定
**セマンティックバージョニング (SemVer)** を採用する。

```
MAJOR.MINOR.PATCH

例: 1.2.3
- MAJOR: 後方互換性のない変更
- MINOR: 後方互換性のある機能追加
- PATCH: 後方互換性のあるバグ修正
```

### 根拠
1. **業界標準**: Python パッケージで広く採用
2. **明確な期待値**: バージョン番号から変更の性質が分かる
3. **依存関係管理**: pip/poetry での依存関係指定が容易

### 影響
- **ポジティブ**: 
  - ユーザーが更新の影響を予測可能
  - CI/CD での自動リリースに適合
- **ネガティブ**: 
  - MAJOR バージョンアップの判断が難しい場合がある

### 初期ロードマップ
- **0.1.0**: 基本機能（AST解析、グラフ構築）
- **0.2.0**: MCP 統合（Tools, Resources）
- **0.3.0**: 高度な機能（コミュニティ検出、変更影響分析）
- **1.0.0**: 安定版リリース

---

## ADR-010: エラー分類と回復戦略

### ステータス
**承認済み** (2024-01)

### コンテキスト
エラーハンドリングの方針を定義する必要がある。

### 決定
エラーを以下のカテゴリに分類し、それぞれに対応する回復戦略を定義する。

```python
class CodeGraphError(Exception):
    """基底例外クラス"""
    pass

class ParseError(CodeGraphError):
    """AST解析エラー - 回復可能"""
    pass

class StorageError(CodeGraphError):
    """ストレージエラー - リトライ可能"""
    pass

class ConfigurationError(CodeGraphError):
    """設定エラー - 回復不能"""
    pass
```

### エラー分類と戦略

| カテゴリ | 例 | 回復戦略 |
|---------|-----|----------|
| 回復可能 | 構文エラー | 部分的パース、ログ記録、継続 |
| リトライ可能 | DB ロック | 指数バックオフでリトライ |
| 回復不能 | 設定不正 | 即座に失敗、明確なエラーメッセージ |

### 根拠
1. **グレースフルデグラデーション**: 一部の失敗でシステム全体が停止しない
2. **デバッグ容易性**: エラーの種類に応じた対応が明確
3. **ユーザー体験**: 適切なエラーメッセージで次のアクションを示唆

### 影響
- **ポジティブ**: 
  - システムの堅牢性向上
  - デバッグ時間の短縮
- **ネガティブ**: 
  - エラーハンドリングコードの増加

### 関連要件
- REQ-NFR-006（エラー耐性）

---

## 決定サマリ

| ADR | 決定内容 | ステータス |
|-----|----------|-----------|
| ADR-001 | Library-First アーキテクチャ | 承認済み |
| ADR-002 | SQLite 採用 | 承認済み |
| ADR-003 | Tree-sitter AST解析 | 承認済み |
| ADR-004 | MCP SDK (Python) | 承認済み |
| ADR-005 | NetworkX グラフ操作 | 承認済み |
| ADR-006 | Pydantic データモデル | 承認済み |
| ADR-007 | asyncio 非同期I/O | 承認済み |
| ADR-008 | LRU キャッシュ戦略 | 承認済み |
| ADR-009 | セマンティックバージョニング | 承認済み |
| ADR-010 | エラー分類と回復戦略 | 承認済み |

---

## 変更履歴

| 日付 | バージョン | 変更内容 |
|------|-----------|----------|
| 2024-01-XX | 1.0.0 | 初版作成 |
